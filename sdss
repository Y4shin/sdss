#!/usr/bin/env python3

# Stow Dotfiles Setup Script (SDSS)
# By Patric Plattner <patric@patricplattner.de>
# License: GNU General Public License v3

# This script manages dotfiles setups using GNU stow. It allows to mix and match
# different dotfiles and handles on the fly switching.

# IMPORTS

import argparse
import sys
import os
import socket
import shutil
import errno
import pathlib
from datetime import datetime as dt
import gnupg
import logging
import subprocess

# CONSTANTS

# List of all commands.
# Comprised of list of 4-tuples in format of:
# (short-name, long-name, desc, dest, takes_argument)
commands = [
    ("-c", "--clone",
     "Clone dotfiles repo into repo folder",
     "clone_repo", 1),
    ("-a", "--activate-package",
     "Activate single package out of a repo. Provide 2 arguments: " +
     "<repo> <package>.", "a_package", 2),
    ("-A", "--activate-repo",
     "Activate all packages out of a repo.",
     "a_repo", 1),
    ("-d", "--deactivate-package",
     "Deactivate singele package out of a repo. Provide 2 arguments: " +
     "<repo> <package>.", "d_package", 2),
    ("-D", "--deactivate-repo",
     "Deactivate all packages out of a repo.",
     "d_repo", 1),
    ("-l", "--list-packages",
     "Lists all packages in a repo.",
     "l_repo", 1),
    ("-L", "--list-repos",
     "Lists all repos.",
     "l_repos", 0),
    ("-V", "--change-version",
     "Change currently deployed version.",
     "change_version", 1),
    ("-R", "--refresh",
     "Refreshes package database.",
     "refresh", 0),
    ("-v", "--print-version",
     "Print version of sdss.",
     "version", 0),
    ("-f", "--get-repos-location",
     "Get the folder which contains the repos.",
     "get_repo_folder", 0),
    ("-F", "--get-package-location",
     "Get the working folder of a package. Provice 2 arguments: " +
     "<repo> <package>.", "get_package_folder", 2),
    ("-d", "--disable-deploy-mode",
     "Disable deploy mode for a repo, to make repo safe to commit.",
     "disable_deploy", 1),
    ("-D", "--enable-deploy-mode",
     "Enable deploy mode for a repo.",
     "enable_deploy", 1)
]

SDSS_REPO_DIR_NAME  = "repos"
SDSS_DATA_FILE_NAME = "sdss.data"
SDSS_VER  = "CUR_VERSION"

# GLOBAL VARS

if os.getenv("XDG_DATA_HOME") is None:
    SDSS_DATA_DIR = os.getenv("SDSS_DATA_DIR") if os.getenv("SDSS_DATA_DIR")\
        is not None else "{}/.local/share/sdss".format(os.getenv("HOME"))
else:
    SDSS_DATA_DIR = os.getenv("SDSS_DATA_DIR") if os.getenv("SDSS_DATA_DIR")\
        is not None else "{}/sdss".format(os.getenv("XDG_DATA_HOME"))
SDSS_DEST_DIR = os.getenv("SDSS_DEST_DIR") if os.getenv("SDSS_DEST_DIR")\
    is not None else os.getenv("HOME")

# CUSTOM EXCEPTIONS

class GPGException(Exception):
    pass

class GPGDecException(GPGException):
    pass

class GPGEncException(GPGException):
    pass
# HOUSEKEEPING FUNCTIONS

def get_dist():
    dist_files = {
      "/etc/os-release": "ID="
    }
    for dist_file in dist_files:
        with open(dist_file, "r") as dfile:
            for line in dfile.readlines():
                if line[:len(dist_files[dist_file])] == dist_files[dist_file]:
                    return line[len(dist_files[dist_file]):-1]
    return None

# Source for this function:
# https://github.com/peakwinter/python-pacman/blob/master/pacman.py
def pacman(flags, pkgs=[], eflgs=[]):
    # Subprocess wrapper, get all data
    if not pkgs:
        cmd = ["pacman", "--noconfirm", flags]
    elif type(pkgs) == list:
        cmd = ["pacman", "--noconfirm", flags]
        cmd += [quote(s) for s in pkgs]
    else:
        cmd = ["pacman", "--noconfirm", flags, pkgs]
    if eflgs and any(eflgs):
        eflgs = [x for x in eflgs if x]
        cmd += eflgs
    p = subprocess.Popen(["sudo"] + cmd, stderr=subprocess.PIPE,
                         stdout=subprocess.PIPE)
    data = p.communicate()
    data = {"code": p.returncode, "stdout": data[0].decode(),
            "stderr": data[1].rstrip(b'\n').decode()}
    return data


def install_dependency(dependency, dist):
    if dist == "arch":
        logging.debug("Attempting to install Arch package {}."
                      .format(dependency))
        if pacman("-Q", dependency)["code"] != 0:
            logging.debug("Package not installed, installing")
            subp = subprocess.Popen(["yay", "-Sy", "--answerclean", "All",
                                     "--answerdiff", "None", "--sudoflags",
                                     "-A", dependency],
                                    stderr=subprocess.PIPE,
                                    stdout=subprocess.PIPE,
                                    stdin=subprocess.PIPE)
            data = subp.communicate(input=(10*"yes\n").encode("ascii"))
            p = {"code": subp.returncode, "stdout": data[0].decode(),
                 "stderr": data[1].rstrip(b'\n').decode()}
            if p["code"] == 0:
                logging.info("Package {} installed."
                             .format(dependency))
            else:
                logging.error("Package {} could not be installed: {}"
                              .format(dependency, p["stderr"]))


def getargs():
    """

    """
    parser = argparse.ArgumentParser(
      description="Stow Dotfiles Setup Script (SDSS). Please only provide one \
      command at a time.")
    for command in commands:
        logging.debug("Adding command: " + str(command))
        if command[0] is not None:
            if command[4] > 0:
                parser.add_argument(command[0], command[1], help=command[2],
                                    dest=command[3], nargs=command[4])
            else:
                parser.add_argument(command[0], command[1], help=command[2],
                                    action="store_true", dest=command[3])
        else:
            if command[4] > 0:
                parser.add_argument(command[1], help=command[2],
                                    dest=command[3], nargs=command[4])
            else:
                parser.add_argument(command[1], help=command[2],
                                    action="store_true", dest=command[3])
    return parser.parse_args()

def get_command(args):
    activated_command = None
    args_dict = vars(args)
    for com in commands:
        command = com[3]
        if args_dict[command] is not None and\
            (args_dict[command] == True or isinstance(args_dict[command], str)\
            or isinstance(args_dict[command], list)):
            if activated_command is None:
                activated_command = (command, args_dict[command])
            else:
                sys.stderr.write("Only provide one command at a time.\n")
                sys.exit(1)
    return activated_command



if __name__ == "__main__":
    dist = get_dist()
    args = getargs()
    comm = get_command(args)
    if comm is None:
        sys.stderr.write("Please provide a command.")
        sys.exit(1)
    command, arg = comm
    if command == "refresh":
        refresh()
    elif command == "clone_repo":
        clone(arg)
    elif command == "a_package":
        activate_package(arg)
    elif command == "a_repo":
        activate_repo(arg)
    elif command == "d_package":
        deactivate_package(arg)
    elif command == "d_repo":
        deactivate_repo(arg)
    elif command == "l_repo":
        list_packages(arg)
    elif command == "l_repos":
        list_repos()
    elif command == "version":
        version()
    elif command == "change_version":
        change_version(arg)
    elif command == "get_repo_folder":
        get_repo_folder()
    elif command == "get_package_folder":
        get_package_folder(arg)
